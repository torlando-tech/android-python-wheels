name: Build pycodec2 for Android (Python 3.11)

on:
  push:
    tags: ['v*']
  workflow_dispatch:
    inputs:
      pycodec2_version:
        description: 'pycodec2 version to build'
        required: false
        default: '4.1.1'
      codec2_version:
        description: 'Codec2 C library version'
        required: false
        default: '1.2.0'

env:
  PYCODEC2_VERSION: ${{ github.event.inputs.pycodec2_version || '4.1.1' }}
  CODEC2_VERSION: ${{ github.event.inputs.codec2_version || '1.2.0' }}

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - abi: arm64_v8a
            cmake_abi: arm64-v8a
            python_arch: aarch64
          - abi: x86_64
            cmake_abi: x86_64
            python_arch: x86_64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install build tools
        run: |
          pip install numpy wheel
          sudo apt-get update
          sudo apt-get install -y cmake ninja-build

      - name: Download Codec2 source
        run: |
          curl -fsSL -H "Accept: application/vnd.github+json" \
            -o codec2.tar.gz \
            "https://api.github.com/repos/drowe67/codec2/tarball/refs/tags/${{ env.CODEC2_VERSION }}"
          tar xzf codec2.tar.gz
          mv drowe67-codec2-* codec2-src

      - name: Set up Android NDK
        run: |
          echo "ANDROID_NDK=$ANDROID_NDK_HOME" >> $GITHUB_ENV
          echo "Using NDK at: $ANDROID_NDK_HOME"

      - name: Build Codec2 for Android
        run: |
          export CODEC2_INSTALL=$PWD/codec2-install
          mkdir -p $CODEC2_INSTALL

          cd codec2-src
          mkdir -p build && cd build

          # Use API level 24 where complex math functions are available in bionic
          cmake .. \
            -G Ninja \
            -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake \
            -DANDROID_ABI=${{ matrix.cmake_abi }} \
            -DANDROID_NATIVE_API_LEVEL=24 \
            -DANDROID_STL=c++_shared \
            -DBUILD_SHARED_LIBS=ON \
            -DUNITTEST=OFF \
            -DINSTALL_EXAMPLES=OFF \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=$CODEC2_INSTALL

          ninja
          ninja install

          echo "CODEC2_INSTALL=$CODEC2_INSTALL" >> $GITHUB_ENV
          ls -la $CODEC2_INSTALL/lib/

      - name: Create wheel with pure Python ctypes wrapper
        run: |
          # Pure Python ctypes wrapper avoids Cython/C extension symbol resolution
          # issues on Android where linker namespace isolation prevents Python C API
          # symbols from being found at dlopen time.

          mkdir -p dist
          mkdir -p wheel_build/pycodec2
          cd wheel_build

          # Copy libcodec2.so
          cp $CODEC2_INSTALL/lib/libcodec2.so pycodec2/

          # Create pure Python ctypes wrapper
          cat > pycodec2/__init__.py << 'PYEOF'
"""
Pure Python wrapper for codec2 using ctypes.
This avoids symbol resolution issues with Cython extensions on Android.
"""
import ctypes
import os
import sys
import numpy as np

# Codec2 C mode constants (from codec2.h)
CODEC2_MODE_3200 = 0
CODEC2_MODE_2400 = 1
CODEC2_MODE_1600 = 2
CODEC2_MODE_1400 = 3
CODEC2_MODE_1300 = 4
CODEC2_MODE_1200 = 5
CODEC2_MODE_700C = 8
CODEC2_MODE_450 = 10
CODEC2_MODE_450PWB = 11

# Bitrate to C mode constant mapping (for pycodec2 API compatibility)
# pycodec2 accepts bitrate values like 700, 1200, etc. and maps them to C constants
_modes = {
    3200: CODEC2_MODE_3200,
    2400: CODEC2_MODE_2400,
    1600: CODEC2_MODE_1600,
    1400: CODEC2_MODE_1400,
    1300: CODEC2_MODE_1300,
    1200: CODEC2_MODE_1200,
    700: CODEC2_MODE_700C,
    450: CODEC2_MODE_450,
}

_libcodec2 = None

def _load_codec2():
    global _libcodec2
    if _libcodec2 is not None:
        return _libcodec2

    paths_to_try = []
    this_dir = os.path.dirname(os.path.abspath(__file__))
    paths_to_try.append(os.path.join(this_dir, 'libcodec2.so'))
    paths_to_try.append('libcodec2.so')

    for path in paths_to_try:
        try:
            _libcodec2 = ctypes.CDLL(path, mode=ctypes.RTLD_GLOBAL)
            break
        except OSError:
            continue

    if _libcodec2 is None:
        raise ImportError("Could not load libcodec2.so")

    _libcodec2.codec2_create.argtypes = [ctypes.c_int]
    _libcodec2.codec2_create.restype = ctypes.c_void_p
    _libcodec2.codec2_destroy.argtypes = [ctypes.c_void_p]
    _libcodec2.codec2_destroy.restype = None
    _libcodec2.codec2_samples_per_frame.argtypes = [ctypes.c_void_p]
    _libcodec2.codec2_samples_per_frame.restype = ctypes.c_int
    _libcodec2.codec2_bits_per_frame.argtypes = [ctypes.c_void_p]
    _libcodec2.codec2_bits_per_frame.restype = ctypes.c_int
    _libcodec2.codec2_bytes_per_frame.argtypes = [ctypes.c_void_p]
    _libcodec2.codec2_bytes_per_frame.restype = ctypes.c_int
    _libcodec2.codec2_encode.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_ubyte), ctypes.POINTER(ctypes.c_short)]
    _libcodec2.codec2_encode.restype = None
    _libcodec2.codec2_decode.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_short), ctypes.POINTER(ctypes.c_ubyte)]
    _libcodec2.codec2_decode.restype = None

    return _libcodec2

class Codec2:
    """Codec2 audio codec wrapper compatible with pycodec2 API."""
    def __init__(self, mode):
        """
        Create a Codec2 instance.

        Args:
            mode: Bitrate value (700, 1200, 1300, 1400, 1600, 2400, 3200) or
                  C mode constant (CODEC2_MODE_*)
        """
        lib = _load_codec2()

        # Map bitrate to C mode constant if needed
        if mode in _modes:
            c_mode = _modes[mode]
        else:
            c_mode = mode  # Assume it's already a C mode constant

        self._c2 = lib.codec2_create(c_mode)
        if not self._c2:
            raise RuntimeError(f"Failed to create Codec2 instance with mode {mode}")
        self._mode = mode
        self._c_mode = c_mode
        self._lib = lib

    def __del__(self):
        if hasattr(self, '_c2') and self._c2 and hasattr(self, '_lib') and self._lib:
            self._lib.codec2_destroy(self._c2)
            self._c2 = None

    def samples_per_frame(self):
        return self._lib.codec2_samples_per_frame(self._c2)

    def bits_per_frame(self):
        return self._lib.codec2_bits_per_frame(self._c2)

    def bytes_per_frame(self):
        return self._lib.codec2_bytes_per_frame(self._c2)

    def encode(self, speech):
        speech = np.asarray(speech, dtype=np.int16)
        speech_ptr = speech.ctypes.data_as(ctypes.POINTER(ctypes.c_short))
        nbytes = self.bytes_per_frame()
        bits = (ctypes.c_ubyte * nbytes)()
        self._lib.codec2_encode(self._c2, bits, speech_ptr)
        return bytes(bits)

    def decode(self, bits):
        bits_array = (ctypes.c_ubyte * len(bits))(*bits)
        nsamples = self.samples_per_frame()
        speech = (ctypes.c_short * nsamples)()
        self._lib.codec2_decode(self._c2, speech, bits_array)
        return np.array(speech, dtype=np.int16)
PYEOF

          # Create METADATA
          mkdir -p pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info
          printf "Metadata-Version: 2.1\nName: pycodec2\nVersion: ${{ env.PYCODEC2_VERSION }}\nSummary: Pure Python ctypes wrapper for codec2\n" \
            > pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/METADATA

          printf "Wheel-Version: 1.0\nGenerator: manual-build\nRoot-Is-Purelib: false\nTag: cp311-cp311-android_21_${{ matrix.abi }}\n" \
            > pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/WHEEL

          printf "pycodec2\n" > pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/top_level.txt

          # Create RECORD with proper sha256 hashes and sizes
          record_entry() {
            local file="$1"
            local path="$2"
            local hash=$(sha256sum "$file" | cut -d' ' -f1 | xxd -r -p | base64 | tr '+/' '-_' | tr -d '=')
            local size=$(stat -c%s "$file")
            echo "$path,sha256=$hash,$size"
          }

          record_entry "pycodec2/__init__.py" "pycodec2/__init__.py" >> pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/RECORD
          record_entry "pycodec2/libcodec2.so" "pycodec2/libcodec2.so" >> pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/RECORD
          record_entry "pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/METADATA" "pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/METADATA" >> pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/RECORD
          record_entry "pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/WHEEL" "pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/WHEEL" >> pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/RECORD
          record_entry "pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/top_level.txt" "pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/top_level.txt" >> pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/RECORD
          echo "pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/RECORD,," >> pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info/RECORD

          # Create the wheel
          WHEEL_NAME="pycodec2-${{ env.PYCODEC2_VERSION }}-cp311-cp311-android_21_${{ matrix.abi }}.whl"
          zip -r "../dist/$WHEEL_NAME" pycodec2 pycodec2-${{ env.PYCODEC2_VERSION }}.dist-info

          echo "Built wheel: $WHEEL_NAME"
          ls -la ../dist/

      - name: Upload wheel artifact
        uses: actions/upload-artifact@v4
        with:
          name: pycodec2-cp311-${{ matrix.abi }}
          path: dist/*.whl
          if-no-files-found: error

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: wheels
          merge-multiple: true

      - name: List wheels
        run: ls -la wheels/

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: wheels/*.whl
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
